<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly Name="System" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.UnitTests.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.UnitTests.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.UnitTests.CUT.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\ExpressionToCodeLib.dll" #>
<#@ import Namespace="System.Reflection" #>
<#@ import Namespace="System.Text" #>
<#@ import Namespace="System.Linq" #>
<#@ import Namespace="ExpressionToCodeLib" #>
<#@ import Namespace="DryIoc" #>
<#@ import Namespace="DryIoc.UnitTests" #>
<#@ import Namespace="DryIoc.MefAttributedModel" #>

<#
IContainer container = new Container(rules => rules
    //.With(Constructor.WithAllResolvableArguments)
    .WithoutSingletonOptimization()
    .WithMefAttributedModel());

container.RegisterExports(new[] { typeof(DryIoc.MefAttributedModel.UnitTests.CUT.IForExport).GetAssembly() });

// container.RegisterMany(new[] { typeof(DryIoc.UnitTests.NewTests).GetAssembly() });
#>

namespace DryIoc.CompileTimeGeneration.Tests
{
    using System;
    public static class GeneratedResolutions
    {
        public static HashTree<KV<Type, object>, FactoryDelegate> 
            Resolutions = HashTree<KV<Type, object>, FactoryDelegate>.Empty;

        static GeneratedResolutions()
        {
<#
    var exprToCode = ExpressionToCode.With(r => r.WithFullTypeNames().WithExplicitMethodTypeArgs());

    foreach (var r in container.GetServiceRegistrations())
    {
        FactoryExpression<object> factoryExpr = null;
        try
        {
            factoryExpr = container.Resolve<FactoryExpression<object>>(r.OptionalKey, IfUnresolved.Throw, r.Type);
            var serviceTypeName = CSharpFriendlyTypeName.Get(r.Type, true);
            var serviceKeyString = new StringBuilder().AppendCode(r.OptionalKey);

            var code = exprToCode.ToCode(factoryExpr.Value);
#>

            Resolutions = Resolutions.AddOrUpdate(new KV<Type, object>(
                typeof(<#=serviceTypeName#>), <#=serviceKeyString#>),
                <#=code#>);
<#
        }
        catch (Exception ex)
        {
#>

/* Exception: <#=CSharpFriendlyTypeName.Get(ex.GetType())#>
----------------------
<#=ex.Message#>
*/
<#
        }
    }
#>
        } // end of static constructor
    }
}