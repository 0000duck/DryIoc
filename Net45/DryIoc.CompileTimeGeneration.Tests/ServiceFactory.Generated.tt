<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly Name="System" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.UnitTests.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.UnitTests.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\DryIoc.MefAttributedModel.UnitTests.CUT.dll" #>
<#@ assembly Name="$(ProjectDir)..\bin\Release\ExpressionToCodeLib.dll" #>
<#@ import Namespace="System.Reflection" #>
<#@ import Namespace="System.Text" #>
<#@ import Namespace="System.Linq" #>
<#@ import Namespace="ExpressionToCodeLib" #>
<#@ import Namespace="DryIoc" #>
<#@ import Namespace="DryIoc.UnitTests" #>
<#@ import Namespace="DryIoc.MefAttributedModel" #>
<#
IContainer container = new Container(rules => rules
    .WithoutSingletonOptimization()
    .WithMefAttributedModel());

container.RegisterExports(new[]
{
    typeof(DryIoc.MefAttributedModel.UnitTests.CUT.IForExport).GetAssembly() // MefAttrModel.UnitTests.CUT
});

#>
namespace DryIoc.CompileTimeGeneration.Tests
{
    using System;
    using System.Linq; // For Cast method required for LazyEnumerable<T>

    public partial class ServiceFactory
    {
        public static HashTree<Type, FactoryDelegate> 
            DefaultResolutions = HashTree<Type, FactoryDelegate>.Empty;

        public static HashTree<Type, HashTree<object, FactoryDelegate>> 
            KeyedResolutions =  HashTree<Type, HashTree<object, FactoryDelegate>>.Empty;

        static ServiceFactory()
        {
<#
    var exprToCode = ExpressionToCode.With(r => r.WithFullTypeNames().WithExplicitMethodTypeArgs());

    var registrations = container.GetServiceRegistrations().Where(r => !r.ServiceType.IsGenericDefinition());
    foreach (var r in registrations)
    {
        try
        {
            var factoryExpr = container.Resolve<FactoryExpression<object>>(r.OptionalServiceKey, IfUnresolved.Throw, r.ServiceType);
            
            var serviceTypeName = ObjectToCode.PlainObjectToCode(r.ServiceType, typeof(Type), true);
            var code = exprToCode.ToCode(factoryExpr.Value);

            if (r.OptionalServiceKey == null)
            {
#>

            DefaultResolutions = DefaultResolutions.AddOrUpdate(
                <#=serviceTypeName #>,
                <#=code #>);
<#
            }
            else
            {
                var serviceKeyString = new StringBuilder().AppendCode(r.OptionalServiceKey);
#>

            KeyedResolutions = KeyedResolutions.AddOrUpdate(
                <#=serviceTypeName#>,     HashTree<object, FactoryDelegate>.Empty.AddOrUpdate(
                <#=serviceKeyString#>,
                <#=code#>),
                (oldEntry, newEntry) => oldEntry.AddOrUpdate(newEntry.Key, newEntry.Value));
<#
            }
        }
        catch (Exception ex)
        {
#>

/* Exception: <#=ObjectToCode.PlainObjectToCode(ex.GetType())#>
----------------------
<#=ex.Message#>
*/
<#
        }
    }
#>
        } // end of static constructor
    }
}