<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.dll" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.MefAttributedModel.dll" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.MefAttributedModel.UnitTests.CUT.dll" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\ExpressionToCodeLib.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import Namespace="System.Linq" #>
<#@ import Namespace="System.Text" #>
<#@ import Namespace="DryIoc" #>
<#@ import Namespace="DryIoc.MefAttributedModel" #>
<#@ import Namespace="DryIoc.MefAttributedModel.UnitTests.CUT" #>
<#@ import Namespace="ExpressionToCodeLib.Unstable_v2_Api" #>
<#
var container = new Container(rules => rules
    .WithoutSingletonOptimization()
    .WithMefAttributedModel());

// NOTE: Specify implementation types to Register here:
//=====================================================
var types = typeof(IDecoratedResult).Assembly.GetLoadedTypes();
container.RegisterExports(types);
//=====================================================

var exprToCode = ExpressionStringify.With(fullTypeNames: true, explicitMethodTypeArgs: true);
var objectToCode = ObjectStringify.WithFullTypeNames;

var idSeed = 0;
var exceptions = new List<Exception>();
var factories = container.GetServiceRegistrations()
    .Where(r => !r.ServiceType.IsGenericDefinition())
    .Select(r =>
    {
        try
        {
            var factoryExpr = container.Resolve<FactoryExpression<object>>(
                r.OptionalServiceKey, IfUnresolved.Throw, r.ServiceType);
            
            var serviceTypeCode = objectToCode.PlainObjectToCode(r.ServiceType, typeof(Type));
            var serviceKeyCode = r.OptionalServiceKey == null ? "null"
                : new StringBuilder().AppendCode(r.OptionalServiceKey).ToString();
                
            var expressionCode = exprToCode.ToCode(factoryExpr.Value.Body);

            return new { Id = ++idSeed, Type = serviceTypeCode, Key = serviceKeyCode, Expression = expressionCode };

        }
        catch (Exception ex)
        {
            exceptions.Add(ex);
            return null;
        }
    })
    .Where(r => r != null)
    .ToArray();
#>
using System;
using System.Linq; // for Enumerable.Cast method required for LazyEnumerable<T>

namespace DryIoc.Zero.UnitTests
{
    public static class ServiceFactory
    {
        public static object Resolve(this IResolverContextProvider r, Type type)
        {
<#
        foreach (var factory in factories.Where(f => f.Key == "null"))
        {
#>
            if (type == <#= factory.Type #>)
                return Create_<#= factory.Id #>(r, null);
<#
        }
#>
            return null;
        }

<#
    foreach (var factory in factories)
    {
#>
        internal static object Create_<#=factory.Id#>(IResolverContextProvider r, IScope scope)
        {
            return <#= factory.Expression #>;
        }

<#        
    }
#>
    }
}