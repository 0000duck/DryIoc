/*
The MIT License (MIT)

Copyright (c) 2013 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

using System;
using System.Collections.Generic;

namespace DryIoc.Zero
{
    /// <summary>Service factory delegate which accepts resolver and resolution scope as parameters and should return service object.
    /// It is stateless because does not include state parameter as <c>DryIoc.FactoryDelegate</c>.</summary>
    /// <param name="r">Provides access to <see cref="IResolver"/> to enable dynamic dependency resolution inside factory delegate.</param>
    /// <param name="scope">Resolution scope parameter. May be null to enable on demand scope creation inside factory delegate.</param>
    /// <returns>Created service object.</returns>
    public delegate object StatelessFactoryDelegate(IResolverContextProvider r, IScope scope);

    /// <summary>Provides methods to register default or keyed factory delegates.</summary>
    public interface IFactoryDelegateRegistrator
    {
        /// <summary>Registers factory delegate with corresponding service type.</summary>
        /// <param name="serviceType">Type</param> <param name="factoryDelegate">Delegate</param>
        void Register(Type serviceType, StatelessFactoryDelegate factoryDelegate);

        /// <summary>Registers factory delegate with corresponding service type and service key.</summary>
        /// <param name="serviceType">Type</param> <param name="serviceKey">Key</param> <param name="factoryDelegate">Delegate</param>
        void Register(Type serviceType, object serviceKey, StatelessFactoryDelegate factoryDelegate);
    }

    /// <summary>Provides action for registering factory delegates in service factory. 
    /// Implementation may be generated by compile-time script (T4).</summary>
    public interface ICompositionRoot
    {
        /// <summary>May register factory delegates with provided registrator.</summary>
        /// <param name="registrator">Registrator.</param>
        void RegisterGeneratedRoots(IFactoryDelegateRegistrator registrator);
    }

    /// <summary>Minimal container which allow to register service factory delegates and then resolve service from them.</summary>
    public class ZeroContainer : IFactoryDelegateRegistrator, IResolverContext, IResolverContextProvider, IDisposable
    {
        /// <summary>Creates container.</summary>
        /// <param name="singletonScope">(optional) Not null singleton scope. May be used by OpenScope.</param>
        /// <param name="openedScope">(optional) Not null opened scope. May be used by OpenScope.</param>
        public ZeroContainer(IScope singletonScope = null, IScope openedScope = null)
        {
            SingletonScope = singletonScope ?? new Scope();
            OpenedScope = openedScope;
            ScopeContext = new ThreadScopeContext();
        }

        public IScope OpenedScope { get; private set; }

        public IScopeContext ScopeContext { get; private set; }

        public ZeroContainer OpenScope()
        {
            var newOpenedScope = new Scope(OpenedScope, null);

            // Replacing current context scope with new nested only if current is the same as nested parent, otherwise throw.
            ScopeContext.SetCurrent(scope =>
                 newOpenedScope.ThrowIf(scope != OpenedScope, Error.NOT_DIRECT_SCOPE_PARENT, OpenedScope, scope));

            return new ZeroContainer(SingletonScope, newOpenedScope);
        }

        public ZeroContainer OpenScopeWithoutContext()
        {
            var newOpenedScope = new Scope(OpenedScope, null);
            return new ZeroContainer(SingletonScope, newOpenedScope);
        }

        /// <summary>Registers factory delegate with corresponding service type.</summary>
        /// <param name="serviceType">Type</param> <param name="factoryDelegate">Delegate</param>
        public void Register(Type serviceType, StatelessFactoryDelegate factoryDelegate)
        {
            _defaultFactories = _defaultFactories.AddOrUpdate(serviceType, factoryDelegate);
        }

        /// <summary>Registers factory delegate with corresponding service type and service key.</summary>
        /// <param name="serviceType">Type</param> <param name="serviceKey">Key</param> <param name="factoryDelegate">Delegate</param>
        public void Register(Type serviceType, object serviceKey, StatelessFactoryDelegate factoryDelegate)
        {
            var entry = _keyedFactories.GetValueOrDefault(serviceType) as HashTree ?? HashTree.Empty;
            _keyedFactories = _keyedFactories.AddOrUpdate(serviceType, entry.AddOrUpdate(serviceKey, factoryDelegate));
        }

        // TODO: Update through refs
        private HashTree _defaultFactories = HashTree.Empty; //<Type -> FactoryDelegate>
        private HashTree _keyedFactories = HashTree.Empty; //<Type -> <Key -> FactoryDelegate>>

        /// <summary>Provides access to resolver.</summary>
        public IResolverContext Resolver
        {
            get { return this; }
        }

        /// <summary>Disposes opened scope or root container including: Singletons, ScopeContext, Make default and keyed factories empty.</summary>
        public void Dispose()
        {
            if (OpenedScope != null)
                OpenedScope.Dispose();
            else
            {
                SingletonScope.Dispose();
                var scopeContext = ScopeContext as IDisposable;
                if (scopeContext != null)
                    scopeContext.Dispose();
                _defaultFactories = HashTree.Empty;
                _keyedFactories = HashTree.Empty;
            }
        }

        /// <summary>Scope containing container singletons.</summary>
        public IScope SingletonScope { get; private set; }

        /// <summary>Returns current scope matching the <paramref name="name"/>. 
        /// If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
        /// <param name="name">May be null</param> <returns>Found scope or throws exception.</returns>
        /// <param name="throwIfNotFound">Says to throw if no scope found.</param>
        /// <exception cref="ZeroContainerException"> with code <see cref="DryIoc.Zero.Error.NO_MATCHED_SCOPE_FOUND"/>.</exception>
        public IScope GetCurrentNamedScope(object name, bool throwIfNotFound)
        {
            var currentScope = ScopeContext == null ? OpenedScope : ScopeContext.GetCurrentOrDefault();
            if (currentScope == null)
            {
                if (throwIfNotFound) Throw.It(Error.NO_CURRENT_SCOPE);
                return null;
            }

            var matchingScope = GetMatchingScopeOrDefault(currentScope, name);
            if (matchingScope == null)
            {
                if (throwIfNotFound) Throw.It(Error.NO_MATCHED_SCOPE_FOUND, name);
                return null;
            }

            return matchingScope;
        }

        private static IScope GetMatchingScopeOrDefault(IScope scope, object name)
        {
            if (name != null)
                while (scope != null && !name.Equals(scope.Name))
                    scope = scope.Parent;
            return scope;
        }

        /// <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
        /// <param name="scope">May be null scope.</param>
        /// <param name="serviceType">Marking scope with resolved service type.</param> 
        /// <param name="serviceKey">Marking scope with resolved service key.</param>
        /// <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        public IScope GetOrCreateResolutionScope(ref IScope scope, Type serviceType, object serviceKey)
        {
            return scope ?? (scope = new Scope(null, new KV(serviceType, serviceKey)));
        }

        public IScope GetMatchingResolutionScope(IScope scope, Type assignableFromServiceType, object serviceKey, bool outermost, bool throwIfNotFound)
        {
            var matchingScope = GetMatchingScopeOrDefault(scope, assignableFromServiceType, serviceKey, outermost);
            if (matchingScope == null)
            {
                if (throwIfNotFound) Throw.It(Error.NO_MATCHED_SCOPE_FOUND, new KV(assignableFromServiceType, serviceKey));
                return null;
            }
            return matchingScope;
        }

        private static IScope GetMatchingScopeOrDefault(IScope scope, Type assignableFromServiceType, object serviceKey, bool outermost)
        {
            if (assignableFromServiceType == null && serviceKey == null)
                return scope;

            IScope matchedScope = null;
            while (scope != null)
            {
                var name = scope.Name as KV;
                if (name != null &&
                    (assignableFromServiceType == null || assignableFromServiceType.IsInstanceOfType(name.Key) &&
                    (serviceKey == null || serviceKey.Equals(name.Value))))
                {
                    matchedScope = scope;
                    if (!outermost) // break on first found match.
                        break;
                }
                scope = scope.Parent;
            }

            return matchedScope;
        }       

        #region IResolver

        /// <summary>Resolves service from container and returns created service object.</summary>
        /// <param name="serviceType">Service type to search and to return.</param>
        /// <param name="ifUnresolved">Says what to do if service is unresolved.</param>
        /// <param name="scope">Propagated resolution scope.</param>
        /// <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        public object ResolveDefault(Type serviceType, IfUnresolved ifUnresolved, IScope scope)
        {
            var factoryDelegate = _defaultFactories.GetValueOrDefault(serviceType) as StatelessFactoryDelegate;
            return factoryDelegate != null
                ? factoryDelegate(this, null)
                : GetDefaultOrThrowIfUnresolved(serviceType, ifUnresolved);
        }

        /// <summary>Resolves keyed service from container and returns created service object.</summary>
        /// <param name="serviceType">Service type to search and to return.</param>
        /// <param name="serviceKey">Optional service key used for registering service.</param>
        /// <param name="ifUnresolved">Says what to do if service is unresolved.</param>
        /// <param name="requiredServiceType">Actual registered service type to use instead of <paramref name="serviceType"/>, 
        ///     or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
        /// <param name="scope">Propagated resolution scope.</param>
        /// <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        /// <remarks>
        /// This method covers all possible resolution input parameters comparing to <see cref="IResolver.ResolveDefault"/>, and
        /// by specifying the same parameters as for <see cref="IResolver.ResolveDefault"/> should return the same result.
        /// </remarks>
        public object ResolveKeyed(Type serviceType, object serviceKey, IfUnresolved ifUnresolved,
            Type requiredServiceType, IScope scope)
        {
            if (serviceKey == null && requiredServiceType == null)
                return ResolveDefault(serviceType, ifUnresolved, scope);

            serviceType = requiredServiceType ?? serviceType;
            var factories = _keyedFactories.GetValueOrDefault(serviceType) as HashTree;
            if (factories != null)
            {
                var factoryDelegate = factories.GetValueOrDefault(serviceKey) as StatelessFactoryDelegate;
                if (factoryDelegate != null)
                    return factoryDelegate(this, null);
            }

            return GetDefaultOrThrowIfUnresolved(serviceType, ifUnresolved);
        }

        /// <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
        /// empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with
        /// this type. Excludes for result composite parent identified by <paramref name="compositeParentKey"/>.</summary>
        /// <param name="serviceType">Return type of an service item.</param>
        /// <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
        /// <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
        /// <param name="compositeParentKey">(optional) Parent service key to exclude to support Composite pattern.</param>
        /// <param name="scope">propagated resolution scope, may be null.</param>
        /// <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        public IEnumerable<object> ResolveMany(Type serviceType, object serviceKey, Type requiredServiceType,
            object compositeParentKey, IScope scope)
        {
            serviceType = requiredServiceType ?? serviceType;

            var factories = _keyedFactories.GetValueOrDefault(serviceType) as HashTree;
            if (factories != null)
            {
                if (serviceKey != null)
                {
                    var factoryDelegate = factories.GetValueOrDefault(serviceKey) as StatelessFactoryDelegate;
                    if (factoryDelegate != null)
                        yield return factoryDelegate(this, scope);
                }
                else
                {
                    foreach (var resolution in factories.Enumerate())
                    {
                        var factoryDelegate = (StatelessFactoryDelegate)resolution.Value;
                        yield return factoryDelegate(this, scope);
                    }
                }
            }
            else
            {
                var factoryDelegate = _defaultFactories.GetValueOrDefault(serviceType) as StatelessFactoryDelegate;
                if (factoryDelegate != null)
                    yield return factoryDelegate(this, scope);
            }
        }

        private static object GetDefaultOrThrowIfUnresolved(Type serviceType, IfUnresolved ifUnresolved)
        {
            if (ifUnresolved == IfUnresolved.Throw) Throw.It(Error.UNABLE_TO_RESOLVE_SERVICE, serviceType);
            return null;
        }

        #endregion
    }

    public class KV
    {
        public readonly object Key, Value;
        public KV(object key, object value) { Key = key; Value = value; }

        /// <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        /// <param name="obj">Object to check equality with.</param> <returns>True if equal.</returns>
        public override bool Equals(object obj)
        {
            var other = obj as KV;
            return other != null
                && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))
                && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));
        }

        /// <summary>Combines key and value hash code. R# generated default implementation.</summary>
        /// <returns>Combined hash code for key-value.</returns>
        public override int GetHashCode()
        {
            unchecked
            {
                return (Key == null ? 0 : Key.GetHashCode() * 397)
                     ^ (Value == null ? 0 : Value.GetHashCode());
            }
        }

        /// <summary>Creates nice string view for Key and Value.</summary><returns>String representation.</returns>
        public override string ToString()
        {
            return "[" + (Key ?? "null") + ", " + (Value ?? "null") + "]";
        }
    }

    public sealed class HashTree
    {
        public static readonly HashTree Empty = new HashTree(IntKeyTree.Empty);
        public bool IsEmpty { get { return _tree.IsEmpty; } }

        private sealed class KVWithConflicts : KV
        {
            public readonly KV[] Conflicts;
            public KVWithConflicts(KV kv, KV[] conflicts) : base(kv.Key, kv.Value) { Conflicts = conflicts; }
        }

        public HashTree AddOrUpdate(object key, object value)
        {
            return new HashTree(_tree.AddOrUpdate(key.GetHashCode(), new KV(key, value), UpdateConflictingKeyValue));
        }

        private static object UpdateConflictingKeyValue(object entryOld, object entryNew)
        {
            var kvOld = (KV)entryOld;
            var kvNew = (KV)entryNew;

            var conflicts = kvOld is KVWithConflicts ? ((KVWithConflicts)kvOld).Conflicts : null;

            // if equal just replace with keeping conflicts intact.
            if (ReferenceEquals(kvOld.Key, kvNew.Key) || kvOld.Key.Equals(kvNew.Key))
                return conflicts == null ? kvNew : new KVWithConflicts(kvNew, conflicts);

            // if keys are not equal but hash is the same:
            // - if no previous conflicts then add new value to conflict with old one. 
            if (conflicts == null)
                return new KVWithConflicts(kvOld, new[] { kvNew });

            // - if some conflicts exist find key in conflict.
            var i = conflicts.Length - 1;
            while (i >= 0 && !Equals(conflicts[i].Key, kvNew.Key)) --i;

            var newConflicts = new KV[i != -1 ? conflicts.Length : conflicts.Length + 1];
            Array.Copy(conflicts, 0, newConflicts, 0, conflicts.Length);
            newConflicts[i != -1 ? i : conflicts.Length] = kvNew;

            return new KVWithConflicts(kvOld, newConflicts);
        }

        public object GetValueOrDefault(object key)
        {
            var kv = _tree.GetValueOrDefault(key.GetHashCode()) as KV;
            return kv != null && (ReferenceEquals(key, kv.Key) || key.Equals(kv.Key))
                ? kv.Value : GetConflictedValueOrDefault(kv, key);
        }

        private static object GetConflictedValueOrDefault(KV kv, object key)
        {
            var conflicts = kv is KVWithConflicts ? ((KVWithConflicts)kv).Conflicts : null;
            if (conflicts != null)
                for (var i = 0; i < conflicts.Length; ++i)
                    if (Equals(conflicts[i].Key, key))
                        return conflicts[i].Value;
            return null;
        }

        public IEnumerable<KV> Enumerate()
        {
            if (!_tree.IsEmpty)
                foreach (var t in _tree.Enumerate())
                {
                    yield return (KV)t.Value;
                    if (t.Value is KVWithConflicts)
                    {
                        var conflicts = ((KVWithConflicts)t.Value).Conflicts;
                        for (var i = 0; i < conflicts.Length; ++i)
                            yield return conflicts[i];
                    }
                }
        }

        #region Implementation

        private readonly IntKeyTree _tree;
        private HashTree(IntKeyTree tree) { _tree = tree; }

        #endregion
    }

    public static class Error
    {
        /// <summary>First error code to identify error range for other possible error code definitions.</summary>
        public readonly static int FIRST_ERROR_CODE = 0;

        /// <summary>List of error messages indexed with code.</summary>
        public readonly static List<string> Messages = new List<string>(100);

        public static readonly int
            UNABLE_TO_RESOLVE_SERVICE = Of(
                "Unable to resolve {0}." + Environment.NewLine +
                "Please ensure you have service registered (with proper key) - 95% of cases." + Environment.NewLine +
                "Remaining 5%: Service does not match the reuse scope, or service has wrong Setup.With(condition), or no Rules.WithUnknownServiceResolver(ForMyService)."),
            NO_CURRENT_SCOPE = Of(
                "No current scope available: probably you are registering to, or resolving from outside of scope."),
            NO_MATCHED_SCOPE_FOUND = Of(
                "Unable to find scope with matching name: {0}."),
            NOT_DIRECT_SCOPE_PARENT = Of(
                "Unable to OpenScope [{0}] because parent scope [{1}] is not current context scope [{2}]." + Environment.NewLine +
                "It is probably other scope was opened in between OR you forgot to Dispose some other scope!");

        public static int Of(string message)
        {
            Messages.Add(message);
            return FIRST_ERROR_CODE + Messages.Count - 1;
        }
    }

    public class ZeroContainerException : InvalidOperationException
    {
        public int Error { get; private set; }

        public ZeroContainerException(int error, string message)
            : base(message)
        {
            Error = error;
        }
    }

    public static class Throw
    {
        public static void It(int error, params object[] args)
        {
            var messageFormat = Error.Messages[error];
            var message = string.Format(messageFormat, args);
            throw new ZeroContainerException(error, message);
        }
    }
}
