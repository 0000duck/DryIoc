<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>

<#@ assembly Name="System.Core" #>
<#@ import Namespace="System.Reflection" #>
<#@ import Namespace="System.Linq" #>
<#@ import Namespace="System.Text" #>

<#@ assembly Name="$(SolutionDir)\packages\DryIoc.dll.2.0.0-rc1build263\lib\net45\DryIoc.dll" #>
<#@ assembly Name="$(SolutionDir)\packages\DryIoc.MefAttributedModel.dll.2.0.0-rc1build263\lib\net45\DryIoc.MefAttributedModel.dll" #>
<#@ assembly Name="$(SolutionDir)\packages\ExpressionToCodeLib.1.5.2.0\lib\net40-Client\ExpressionToCodeLib.dll" #>
<#@ import Namespace="DryIoc" #>
<#@ import Namespace="DryIoc.MefAttributedModel" #>
<#@ import Namespace="ExpressionToCodeLib.Unstable_v2_Api" #>
<#
var container = new Container(rules => rules
    .WithoutSingletonOptimization() // Required for stateless factory delegates generation
    .WithMefAttributedModel());

// NOTE: TODO: Specify assemblies with types to Register here:
//======================================================
//// Specify assembly as file...
//var assembly = Assembly.LoadFrom(Host.ResolvePath("DryIoc.MefAttributedModel.UnitTests.CUT.dll"));
//// Or by known type from...
//var assembly = typeof(TypeFromYourAssembly).Assembly;

var types = assembly.GetLoadedTypes();
container.RegisterExports(types);
//======================================================
#>
using System.Linq; // for Enumerable.Cast method required for LazyEnumerable<T>

namespace DryIoc.Zero
{
    public sealed class CompositionRoot : ICompositionRoot
    {
        public static readonly ICompositionRoot Default = new CompositionRoot();        
        public void RegisterGeneratedRoots(IFactoryDelegateRegistrator registrator)
        {
<#
    var exprToCode = ExpressionStringify.With(fullTypeNames: true, explicitMethodTypeArgs: true);

    var registrations = container.GetServiceRegistrations().Where(r => !r.ServiceType.IsGenericDefinition());
    foreach (var r in registrations)
    {
        try
        {
            var factoryExpr = container.Resolve<FactoryExpression<object>>(r.OptionalServiceKey, IfUnresolved.Throw, r.ServiceType);
            
            var serviceTypeName = ObjectStringify.WithFullTypeNames.PlainObjectToCode(r.ServiceType, typeof(Type));
            var delegateBody = exprToCode.ToCode(factoryExpr.Value.Body);

            if (r.OptionalServiceKey == null)
            {
#>
            registrator.Register(<#=serviceTypeName #>, 
                (r, scope) => <#=delegateBody #>);

<#
            }
            else
            {
                var serviceKeyString = new StringBuilder().AppendCode(r.OptionalServiceKey).ToString();
#>
            registrator.Register(<#=serviceTypeName #>, <#=serviceKeyString#>, 
                (r, scope) => <#=delegateBody #>);

<#
            }
        }
        catch (Exception ex)
        {
#>
/* 
Resolution of <#=ObjectStringify.WithFullTypeNames.TypeNameToCode(r.ServiceType)#>
Failed with: <#=ObjectStringify.WithFullTypeNames.TypeNameToCode(ex.GetType())#>
----------------------
<#=ex.Message#>
*/
<#
        }
    }
#>
        } // end of registrationss
    }
}