<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.dll" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.MefAttributedModel.dll" #>
<#@ assembly Name="$(ProjectDir)\..\bin\Release\ExpressionToCodeLib.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import Namespace="System.Linq" #>
<#@ import namespace="System.Linq.Expressions" #>
<#@ import Namespace="System.Text" #>
<#@ import Namespace="DryIoc" #>
<#@ import Namespace="DryIoc.MefAttributedModel" #>
<#@ import Namespace="ExpressionToCodeLib.Unstable_v2_Api" #>

<#@ assembly Name="$(ProjectDir)\..\bin\Release\DryIoc.MefAttributedModel.UnitTests.CUT.dll" #>
<#@ import Namespace="DryIoc.MefAttributedModel.UnitTests.CUT" #>

<#
/* 
requires assemblies:
$(SolutionDir)packages\DryIoc.dll.2.0.0\lib\net45\DryIoc.dll
$(SolutionDir)packages\DryIoc.MefAttributedModel.dll.2.0.0\lib\net45\DryIoc.MefAttributedModel.dll
$(SolutionDir)packages\ExpressionToCodeLib.1.5.2.0\lib\net40-Client\ExpressionToCodeLib.dll
*/

var container = new Container(rules => rules
    .WithoutSingletonOptimization()
    .WithMefAttributedModel());

// NOTE: Specify implementation types to Register here:
//=====================================================
var types = typeof(IDecoratedResult).Assembly.GetLoadedTypes();
container.RegisterExports(types);
//=====================================================

var exprToCode = ExpressionStringify.With(fullTypeNames: true, explicitMethodTypeArgs: true);
var objectToCode = ObjectStringify.WithFullTypeNames;

var idSeed = 0;
var exceptions = new List<Exception>();
var factories = container.GetServiceRegistrations()
    .Where(r => !r.ServiceType.IsGenericDefinition())
    .Where(r => r.Factory.Setup.AsResolutionRoot)
    .Select(r =>
    {
        try
        {
            var factoryExpr = container.Resolve<LambdaExpression>(r.OptionalServiceKey, IfUnresolved.Throw, r.ServiceType);
            
            var serviceTypeCode = objectToCode.PlainObjectToCode(r.ServiceType, typeof(Type));
            var serviceKeyCode = r.OptionalServiceKey == null ? "null"
                : new StringBuilder().AppendCode(r.OptionalServiceKey).ToString();
                
            var expressionCode = exprToCode.ToCode(factoryExpr.Body);

            return new { Id = ++idSeed, Type = serviceTypeCode, Key = serviceKeyCode, Expression = expressionCode };

        }
        catch (Exception ex)
        {
            exceptions.Add(ex);
            return null;
        }
    })
    .Where(r => r != null)
    .ToArray();
#>
using System;
using System.Linq; // for Enumerable.Cast method required for LazyEnumerable<T>
using System.Collections.Generic;

namespace DryIoc.Zero
{
/* 
Exceptions happened during resolution:
======================================

<#
    foreach (var ex in exceptions)
    {
#>
<#=objectToCode.TypeNameToCode(ex.GetType())#>:
<#=ex.Message#>

<#
    }
#>
======================================
end of exception list
*/

    partial class ZeroContainer
    {
        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        partial void ResolveGenerated(ref object service, Type serviceType, IScope scope)
        {
<#
        var count = 0;
        foreach (var factory in factories.Where(f => f.Key == "null"))
        {
            if (count++ > 0) WriteLine(@"
            else");
#>
            if (serviceType == <#= factory.Type #>)
                service = Create_<#= factory.Id #>(this, scope);
<#
        }
#>
        }

        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        partial void ResolveGenerated(ref object service, Type serviceType, object serviceKey, IScope scope)
        {
<#
        var groupCount = 0;
        foreach (var factoryGroup in factories.Where(f => f.Key != "null").GroupBy(f => f.Type))
        {
            if (groupCount++ > 0) WriteLine(@"
            else");
#>
            if (serviceType == <#= factoryGroup.Key #>) 
            {
<#
            var inGroupCount = 0;
            foreach (var factory in factoryGroup)
            {
                if (inGroupCount++ > 0) WriteLine(@"
                else");
#>
                if (<#= factory.Key #>.Equals(serviceKey))
                    service = Create_<#= factory.Id #>(this, scope);
<#
            }

#>
            }
<#
        }
#>
        }

        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        partial void ResolveManyGenerated(ref IEnumerable<KV> services, Type serviceType) 
        {
            services = ResolveManyGenerated(serviceType);
        }

        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        private IEnumerable<KV> ResolveManyGenerated(Type serviceType)
        {
<#
        foreach (var factoryGroup in factories.GroupBy(f => f.Type))
        {
#>
            if (serviceType == <#= factoryGroup.Key #>)
            {
<#
            foreach (var factory in factoryGroup)
            {
#>
                yield return new KV(<#= factory.Key #>, (StatelessFactoryDelegate)Create_<#= factory.Id #>);
<#
            }
#>
            }

<#
        }
#>
        }

<#
    foreach (var factory in factories)
    {
#>
        internal static object Create_<#=factory.Id#>(IResolverContext r, IScope scope)
        {
            return <#= factory.Expression #>;
        }

<#        
    }
#>
    }
}