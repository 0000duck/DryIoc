// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2018 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included AddOrUpdateServiceFactory
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

namespace ImTools
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]

    /// <summary>Helpers for functional composition</summary>
    public static class Fun
    {
        /// <summary>Always a true condition.</summary>
        public static bool Always<T>(T _) => true;

        /// <summary>Identity function returning passed argument as result.</summary>
        public static T Id<T>(T x) => x;

        /// <summary>Piping</summary>
        public static R Do<T, R>(this T x, Func<T, R> @do) => @do(x);

        /// <summary>Piping</summary>
        public static void Do<T>(this T x, Action<T> @do) => @do(x);
    }

    /// <summary>Helpers for lazy instantiations</summary>
    public static class Lazy
    {
        /// <summary>Provides result type inference for creation of lazy.</summary>
        public static Lazy<T> Of<T>(Func<T> valueFactory) => new Lazy<T>(valueFactory);
    }

    /// <summary>Methods to work with immutable arrays and some sugar.</summary>
    public static class ArrayTools
    {
        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }

        /// <summary>Returns singleton empty array of provided type.</summary> 
        /// <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        public static T[] Empty<T>() => EmptyArray<T>.Value;

        /// <summary>Wraps item in array.</summary>
        public static T[] One<T>(this T one) => new[] { one };

        /// <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;

        /// <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();

        /// Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());

        /// Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();

        /// <summary>Returns new array consisting from all items from source array then all items from added array.
        /// If source is null or empty, then added array will be returned.
        /// If added is null or empty, then source will be returned.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array with leading items.</param>
        /// <param name="added">Array with following items.</param>
        /// <returns>New array with items of source and added arrays.</returns>
        public static T[] Append<T>(this T[] source, params T[] added)
        {
            if (added == null || added.Length == 0)
                return source;
            if (source == null || source.Length == 0)
                return added;

            var result = new T[source.Length + added.Length];
            Array.Copy(source, 0, result, 0, source.Length);
            if (added.Length == 1)
                result[source.Length] = added[0];
            else
                Array.Copy(added, 0, result, source.Length, added.Length);
            return result;
        }

        /// <summary>Performant concat of enumerables in case of arrays.
        /// But performance will degrade if you use Concat().Where().</summary>
        /// <typeparam name="T">Type of item.</typeparam>
        /// <param name="source">goes first.</param>
        /// <param name="other">appended to source.</param>
        /// <returns>empty array or concat of source and other.</returns>
        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>
            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());

        /// <summary>Returns new array with <paramref name="value"/> appended, 
        /// or <paramref name="value"/> at <paramref name="index"/>, if specified.
        /// If source array could be null or empty, then single value item array will be created despite any index.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array to append value to.</param>
        /// <param name="value">Value to append.</param>
        /// <param name="index">(optional) Index of value to update.</param>
        /// <returns>New array with appended or updated value.</returns>
        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)
        {
            if (source == null || source.Length == 0)
                return new[] { value };
            var sourceLength = source.Length;
            index = index < 0 ? sourceLength : index;
            var result = new T[index < sourceLength ? sourceLength : sourceLength + 1];
            Array.Copy(source, result, sourceLength);
            result[index] = value;
            return result;
        }

        /// <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
        /// then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
        /// <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(source[i]))
                        return i;
            return -1;
        }

        /// <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="value">Value to look up.</param>
        /// <returns>Index of item equal to value, or -1 item is not found.</returns>
        public static int IndexOf<T>(this T[] source, T value)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (Equals(item, value))
                        return i;
                }
            return -1;
        }

        /// <summary>Produces new array without item at specified <paramref name="index"/>. 
        /// Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
        /// <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)
                return source;
            if (index == 0 && source.Length == 1)
                return new T[0];
            var result = new T[source.Length - 1];
            if (index != 0)
                Array.Copy(source, 0, result, 0, index);
            if (index != result.Length)
                Array.Copy(source, index + 1, result, index, result.Length - index);
            return result;
        }

        /// <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
        /// <returns>New array with value removed or original array if value is not found.</returns>
        public static T[] Remove<T>(this T[] source, T value) =>
            source.RemoveAt(source.IndexOf(value));

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(item))
                        return item;
                }
            return default(T);
        }

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>
            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);

        /// <summary>Returns element if collection consist on single element, otherwise returns default value.
        /// It does not throw for collection with many elements</summary>
        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.Count == 1 ? list[0] : default(T);

            if (source == null)
                return default(T);

            using (var e = source.GetEnumerator())
            {
                if (!e.MoveNext())
                    return default(T);
                var it = e.Current;
                if (!e.MoveNext())
                    return it;
                return default(T);
            }
        }

        /// <summary>Does <paramref name="action"/> for each item</summary>
        public static void DoPer<T>(this T[] source, Action<T> action)
        {
            if (!source.IsNullOrEmpty())
                for (var i = 0; i < source.Length; i++)
                    action(source[i]);
        }

        private static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)
        {
            if (results == null)
            {
                var newResults = new T[count];
                if (count == 1)
                    newResults[0] = source[sourcePos];
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = source[j];
                return newResults;
            }

            var matchCount = results.Length;
            var appendedResults = new T[matchCount + count];
            if (matchCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, matchCount);

            if (count == 1)
                appendedResults[matchCount] = source[sourcePos];
            else
                Array.Copy(source, sourcePos, appendedResults, matchCount, count);

            return appendedResults;
        }

        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(source[j]);
            }

            return appendedResults;
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        public static T[] Match<T>(this T[] source, Func<T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { source[0], source[1] }
                    : condition0 ? new[] { source[0] }
                        : condition1 ? new[] { source[1] }
                            : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;

            var i = 0;
            while (i < source.Length)
            {
                matchFound = condition(source[i]);
                if (!matchFound)
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }
                ++i;
            }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            if (matches != null)
                return matches;

            if (matchStart != 0) // no matches
                return Empty<T>();

            return source;
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
        /// <returns>New array of result items.</returns>
        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(item) ? new[] { map(item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { map(source[0]), map(source[1]) }
                : condition0 ? new[] { map(source[0]) }
                : condition1 ? new[] { map(source[1]) }
                : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            while (i < source.Length)
            {
                matchFound = condition(source[i]);
                if (!matchFound)
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }
                ++i;
            }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, map, matches);

            if (matches != null)
                return matches;

            if (matchStart != 0) // no matches
                return Empty<R>();

            return AppendTo(source, 0, source.Length, map);
        }

        /// <summary>Maps all items from source to result array.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static R[] Map<T, R>(this T[] source, Func<T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(source[0]) };

            if (sourceCount == 2)
                return new[] { map(source[0]), map(source[1]) };

            if (sourceCount == 3)
                return new[] { map(source[0]), map(source[1]), map(source[2]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(source[i]);
            return results;
        }

        /// <summary>Maps all items from source to result collection. 
        /// If possible uses fast array Map otherwise Enumerable.Select.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>
            source is T[] arr ? arr.Map(map) : source?.Select(map);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>
            source is T[] arr ? arr.Match(condition) : source?.Where(condition);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array,
        /// otherwise just calls Where, Select</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>
            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);
    }

    /// <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="Ref.Swap{T}"/>.</summary>
    /// <typeparam name="T">Type of object to wrap.</typeparam>
    public sealed class Ref<T> where T : class
    {
        /// <summary>Gets the wrapped value.</summary>
        public T Value => _value;

        /// <summary>Creates ref to object, optionally with initial value provided.</summary>
        /// <param name="initialValue">(optional) Initial value.</param>
        public Ref(T initialValue = default(T))
        {
            _value = initialValue;
        }

        /// <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="Ref.Swap{T}"/> for details.</summary>
        /// <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
        /// <returns>Returns old object value the same way as <see cref="Interlocked.Exchange(ref int,int)"/></returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        public T Swap(Func<T, T> getNewValue) =>
            Ref.Swap(ref _value, getNewValue);

        /// <summary>Just sets new value ignoring any intermingled changes.</summary>
        /// <param name="newValue"></param> <returns>old value</returns>
        public T Swap(T newValue) =>
            Interlocked.Exchange(ref _value, newValue);

        /// <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
        /// <param name="currentValue"></param> <param name="newValue"></param>
        /// <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
        /// <example><c>[!CDATA[
        /// var value = SomeRef.Value;
        /// if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
        ///     SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
        /// ]]</c></example>
        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>
            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;

        private T _value;
    }

    /// <summary>Provides optimistic-concurrency consistent <see cref="Swap{T}"/> operation.</summary>
    public static class Ref
    {
        /// <summary>Factory for <see cref="Ref{T}"/> with type of value inference.</summary>
        /// <typeparam name="T">Type of value to wrap.</typeparam>
        /// <param name="value">Initial value to wrap.</param>
        /// <returns>New ref.</returns>
        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);

        /// <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
        /// <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);

        /// <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
        /// Second, it checks that original value is not changed. 
        /// If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
        /// <typeparam name="T">Type of value to swap.</typeparam>
        /// <param name="value">Reference to change to new value</param>
        /// <param name="getNewValue">Delegate to get value from old one.</param>
        /// <returns>Old/original value. By analogy with <see cref="Interlocked.Exchange(ref int,int)"/>.</returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        public static T Swap<T>(ref T value, Func<T, T> getNewValue) where T : class
        {
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > RETRY_COUNT_UNTIL_THROW)
                    throw new InvalidOperationException(_errorRetryCountExceeded);
            }
        }

        private const int RETRY_COUNT_UNTIL_THROW = 50;
        private static readonly string _errorRetryCountExceeded =
            "Ref retried to Update for " + RETRY_COUNT_UNTIL_THROW + " times But there is always someone else intervened.";
    }

    /// <summary>Printable thingy via provided printer </summary>
    public interface IPrintable
    {
        /// <summary>Print to the provided string builder via the provided printer.</summary>
        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
    }

    /// <summary>Produces good enough hash codes for the fields</summary>
    public static class Hasher
    {
        /// <summary>Combines hashes of two fields</summary>
        public static int Combine<T1, T2>(T1 a, T2 b) =>
            Combine(a?.GetHashCode() ?? 0, b?.GetHashCode() ?? 0);

        /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        public static int Combine(int h1, int h2)
        {
            if (h1 == 0) return h2;
            unchecked
            {
                return (h1 << 5) + h1 ^ h2;
            }
        }
    }

    /// <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
    /// which is different from System value type <see cref="KeyValuePair{TKey,TValue}"/>.
    /// In addition provides <see cref="Equals"/> and <see cref="GetHashCode"/> implementations.</summary>
    /// <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
    public class KV<K, V> : IPrintable
    {
        /// <summary>Key.</summary>
        public readonly K Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
        /// <param name="key">key.</param><param name="value">value.</param>
        public KV(K key, V value)
        {
            Key = key;
            Value = value;
        }

        /// <inheritdoc />
        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
             s.Append("(").Do(b => Key == null ? b : printer(b, Key))
              .Append(", ").Do(b => Value == null ? b : printer(b, Value))
              .Append(')');

        /// <summary>Creates nice string view.</summary><returns>String representation.</returns>
        public override string ToString() =>
            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();

        /// <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        public override bool Equals(object obj)
        {
            var other = obj as KV<K, V>;
            return other != null
                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))
                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));
        }

        /// <summary>Combines key and value hash code</summary>
        public override int GetHashCode() => Hasher.Combine(Key, Value);
    }

    /// <summary>Helpers for <see cref="KV{K,V}"/>.</summary>
    public static class KV
    {
        /// <summary>Creates the key value pair.</summary>
        /// <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
        /// <param name="key">Key</param> <param name="value">Value</param> <returns>New pair.</returns>
        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);

        /// <summary>Creates the new pair with new key and old value.</summary>
        /// <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
        /// <param name="source">Source value</param> <param name="key">New key</param> <returns>New pair</returns>
        public static KV<K, V> WithKey<K, V>(this KV<K, V> source, K key) => new KV<K, V>(key, source.Value);

        /// <summary>Creates the new pair with old key and new value.</summary>
        /// <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
        /// <param name="source">Source value</param> <param name="value">New value.</param> <returns>New pair</returns>
        public static KV<K, V> WithValue<K, V>(this KV<K, V> source, V value) => new KV<K, V>(source.Key, value);
    }

    /// <summary>Simple helper for creation of the pair of two parts.</summary>
    public static class KeyValuePair
    {
        /// <summary>Pairs key with value.</summary>
        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) =>
            new KeyValuePair<K, V>(key, value);
    }

    /// <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
    public struct Opt<T>
    {
        /// <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        public static implicit operator Opt<T>(T value) => new Opt<T>(value);

        /// <summary>Argument value.</summary>
        public readonly T Value;

        /// <summary>Indicates that value is provided.</summary>
        public readonly bool HasValue;

        /// <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        public Opt(T value)
        {
            HasValue = true;
            Value = value;
        }

        /// <summary>Helper to get value or default value if value is not present.</summary>
        public T OrDefault(T defaultValue = default(T)) => HasValue ? Value : defaultValue;
    }

    /// <summary>Immutable list - simplest linked list with Head and Rest.</summary>
    /// <typeparam name="T">Type of the item.</typeparam>
    public sealed class ImList<T>
    {
        /// <summary>Empty list to Push to.</summary>
        public static readonly ImList<T> Empty = new ImList<T>();

        /// <summary>True for empty list.</summary>
        public bool IsEmpty => Tail == null;

        /// <summary>First value in a list.</summary>
        public readonly T Head;

        /// <summary>The rest of values or Empty if list has a single value.</summary>
        public readonly ImList<T> Tail;

        /// <summary>Prepends new value and returns new list.</summary>
        /// <param name="head">New first value.</param>
        /// <returns>List with the new head.</returns>
        public ImList<T> Prep(T head) => new ImList<T>(head, this);

        /// <summary>Enumerates the list.</summary>
        /// <returns>Each item in turn.</returns>
        public IEnumerable<T> Enumerate()
        {
            if (IsEmpty)
                yield break;
            for (var list = this; !list.IsEmpty; list = list.Tail)
                yield return list.Head;
        }

        #region Implementation

        private ImList() { }

        private ImList(T head, ImList<T> tail)
        {
            Head = head;
            Tail = tail;
        }

        #endregion
    }

    /// <summary>Extension methods providing basic operations on a list.</summary>
    public static class ImList
    {
        /// <summary>This a basically a Fold function, to address needs in Map, Filter, Reduce.</summary>
        /// <typeparam name="T">Type of list item.</typeparam>
        /// <typeparam name="R">Type of result.</typeparam>
        /// <param name="source">List to fold.</param>
        /// <param name="initialValue">From were to start.</param>
        /// <param name="collect">Collects list item into result</param>
        /// <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        public static R To<T, R>(this ImList<T> source, R initialValue, Func<T, R, R> collect)
        {
            if (source.IsEmpty)
                return initialValue;
            var value = initialValue;
            for (; !source.IsEmpty; source = source.Tail)
                value = collect(source.Head, value);
            return value;
        }

        /// <summary>Form of fold function with element index for convenience.</summary>
        /// <typeparam name="T">Type of list item.</typeparam>
        /// <typeparam name="R">Type of result.</typeparam>
        /// <param name="source">List to fold.</param>
        /// <param name="initialValue">From were to start.</param>
        /// <param name="collect">Collects list item into result</param>
        /// <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        public static R To<T, R>(this ImList<T> source, R initialValue, Func<T, int, R, R> collect)
        {
            if (source.IsEmpty)
                return initialValue;
            var value = initialValue;
            for (var i = 0; !source.IsEmpty; source = source.Tail)
                value = collect(source.Head, i++, value);
            return value;
        }

        /// <summary>Returns new list in reverse order.</summary>
        /// <typeparam name="T">List item type</typeparam> <param name="source">List to reverse.</param>
        /// <returns>New list. If list consist on single element, then the same list.</returns>
        public static ImList<T> Reverse<T>(this ImList<T> source)
        {
            if (source.IsEmpty || source.Tail.IsEmpty)
                return source;
            return source.To(ImList<T>.Empty, (it, _) => _.Prep(it));
        }

        /// <summary>Maps the items from the first list to the result list.</summary>
        /// <typeparam name="T">source item type.</typeparam> 
        /// <typeparam name="R">result item type.</typeparam>
        /// <param name="source">input list.</param> <param name="map">converter func.</param>
        /// <returns>result list.</returns>
        public static ImList<R> Map<T, R>(this ImList<T> source, Func<T, R> map)
        {
            return source.To(ImList<R>.Empty, (it, _) => _.Prep(map(it))).Reverse();
        }

        /// <summary>Maps the items from the first list to the result list with item index.</summary>
        /// <typeparam name="T">source item type.</typeparam> 
        /// <typeparam name="R">result item type.</typeparam>
        /// <param name="source">input list.</param> <param name="map">converter func.</param>
        /// <returns>result list.</returns>
        public static ImList<R> Map<T, R>(this ImList<T> source, Func<T, int, R> map)
        {
            return source.To(ImList<R>.Empty, (it, i, _) => _.Prep(map(it, i))).Reverse();
        }

        /// <summary>Copies list to array.</summary> 
        public static T[] ToArray<T>(this ImList<T> source) =>
            source.IsEmpty ? ArrayTools.Empty<T>() :
            source.Tail.IsEmpty ? new[] { source.Head } :
            source.Enumerate().ToArray();
    }

    /// Given the old value should and the new value should return result updated value.
    public delegate V Update<V>(V oldValue, V newValue);

    /// Update handler including the key
    public delegate V Update<K, V>(K key, V oldValue, V newValue);

    /// <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
    public sealed class ImMap<V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImMap<V> Empty = new ImMap<V>();

        /// <summary>Key.</summary>
        public readonly int Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public readonly ImMap<V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public readonly ImMap<V> Right;

        /// <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        public readonly int Height;

        /// <summary>Returns true is tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value) =>
            Height == 0 // add new node
                ? new ImMap<V>(key, value)
                : (key == Key // update found node
                    ? new ImMap<V>(key, value, Left, Right, Height)
                    : (key < Key // search for node
                        ? (Height == 1
                            ? new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, height: 2)
                            : Balance(Key, Value, Left.AddOrUpdate(key, value), Right))
                        : (Height == 1
                            ? new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), height: 2)
                            : Balance(Key, Value, Left, Right.AddOrUpdate(key, value)))));

        /// <summary>Returns new tree with added or updated value for specified key.</summary>
        /// <param name="key">Key</param> <param name="value">Value</param>
        /// <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
        /// <returns>New tree.</returns>
        public ImMap<V> AddOrUpdate(int key, V value, Update<V> updateValue) =>
            AddOrUpdateImpl(key, value, false, updateValue);

        /// <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
        /// <param name="key"></param> <param name="value"></param>
        /// <returns>New tree if key is found, or the same tree otherwise.</returns>
        public ImMap<V> Update(int key, V value) =>
            AddOrUpdateImpl(key, value, true, null);

        // todo: Leak, cause returned ImMap references left and right sub-trees - replace with `KeyValuePair`
        /// <summary>Returns all sub-trees enumerated from left to right.</summary> 
        /// <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        public IEnumerable<ImMap<V>> Enumerate()
        {
            if (Height == 0)
                yield break;

            var parents = new ImMap<V>[Height];

            var node = this;
            var parentCount = -1;
            while (node.Height != 0 || parentCount != -1)
            {
                if (node.Height != 0)
                {
                    parents[++parentCount] = node;
                    node = node.Left;
                }
                else
                {
                    node = parents[parentCount--];
                    yield return node;
                    node = node.Right;
                }
            }
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        public ImMap<V> Remove(int key) =>
            RemoveImpl(key);

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : (Key + ":" + Value);

        #region Implementation

        internal ImMap() { }

        internal ImMap(int key, V value)
        {
            Key = key;
            Value = value;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right, int height)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = height;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = left.Height > right.Height ? left.Height + 1 : right.Height + 1;
        }

        private ImMap<V> AddOrUpdateImpl(int key, V value, bool updateOnly, Update<V> update)
        {
            return Height == 0 ? // tree is empty
                (updateOnly ? this : new ImMap<V>(key, value))
                : (key == Key ? // actual update
                    new ImMap<V>(key, update == null ? value : update(Value, value), Left, Right)
                    : (key < Key    // try update on left or right sub-tree
                        ? Balance(Key, Value, Left.AddOrUpdateImpl(key, value, updateOnly, update), Right)
                        : Balance(Key, Value, Left, Right.AddOrUpdateImpl(key, value, updateOnly, update))));
        }

        internal static ImMap<V> Balance(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(left.Key, left.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(key, value, leftRight.Right, right));
                }

                // one rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImMap<V>(left.Key, left.Value,
                    leftLeft,
                    new ImMap<V>(key, value, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                {
                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(key, value, left, rightLeft.Left),
                        new ImMap<V>(right.Key, right.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(right.Key, right.Value,
                    new ImMap<V>(key, value, left, rightLeft),
                    rightRight);
            }

            return new ImMap<V>(key, value, left, right);
        }

        private ImMap<V> RemoveImpl(int key, bool ignoreKey = false)
        {
            if (Height == 0)
                return this;

            ImMap<V> result;
            if (key == Key || ignoreKey) // found node
            {
                if (Height == 1) // remove node
                    return Empty;

                if (Right.IsEmpty)
                    result = Left;
                else if (Left.IsEmpty)
                    result = Right;
                else
                {
                    // we have two children, so remove the next highest node and replace this node with it.
                    var successor = Right;
                    while (!successor.Left.IsEmpty) successor = successor.Left;
                    result = new ImMap<V>(successor.Key, successor.Value,
                        Left, Right.RemoveImpl(successor.Key, ignoreKey: true));
                }
            }
            else if (key < Key)
                result = Balance(Key, Value, Left.RemoveImpl(key), Right);
            else
                result = Balance(Key, Value, Left, Right.RemoveImpl(key));

            return result;
        }

        #endregion
    }

    /// ImMap methods
    public static class ImMap
    {
        /// Get value for found key or default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key, V defaultValue = default(V))
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Height != 0 ? map.Value : defaultValue;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V> map, int key, out V value)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;

            if (map.Height != 0)
            {
                value = map.Value;
                return true;
            }

            value = default(V);
            return false;
        }
    }

    /// Immutable http://en.wikipedia.org/wiki/AVL_tree 
    /// where node key is the hash code of <typeparamref name="K"/>.
    public class ImHashMap<K, V>
    {
        /// Empty tree to start with.
        public static readonly ImHashMap<K, V> Empty = new Branch();

        /// Returns true if tree is empty. Valid for a `Branch`.
        public bool IsEmpty => this == Empty;

        /// Calculated key hash.
        public readonly int Hash;

        /// Key of type K that should support <see cref="object.Equals(object)"/> and <see cref="object.GetHashCode"/>
        public readonly K Key;

        /// Value of any type V.
        public readonly V Value;

        /// The height.
        public int Height => this is Branch b ? b.BranchHeight : 1;

        /// Left branch.
        public ImHashMap<K, V> Left => (this as Branch)?.LeftNode;

        /// Right branch.
        public ImHashMap<K, V> Right => (this as Branch)?.RightNode;

        /// Conflicts
        public virtual KV<K, V>[] Conflicts => null;

        /// The branch node
        public class Branch : ImHashMap<K, V>
        {
            /// Left sub-tree/branch, or `null`!
            public readonly ImHashMap<K, V> LeftNode;

            /// Right sub-tree/branch, or `null`!
            public readonly ImHashMap<K, V> RightNode;

            /// Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.
            public readonly int BranchHeight;

            /// Empty map
            public Branch() { }

            /// Constructs the branch node
            public Branch(int hash, K key, V value, ImHashMap<K, V> left, ImHashMap<K, V> right, int height)
                : base(hash, key, value)
            {
                LeftNode = left;
                RightNode = right;
                BranchHeight = height;
            }

            /// Works on the branch
            public Branch AddOrUpdateBranch(int hash, K key, V value, Update<K, V> update, ref bool isUpdated, ref V updatedOldValue)
            {
                if (hash == Hash)
                {
                    if (ReferenceEquals(Key, key) || Key.Equals(key))
                    {
                        var newValue = update(Key, Value, value);
                        if (ReferenceEquals(newValue, Value) || newValue?.Equals(Value) == true)
                            return this;

                        isUpdated = true;
                        updatedOldValue = Value;
                        return CreateBranch(hash, key, newValue, Conflicts, LeftNode, RightNode, BranchHeight);
                    }

                    return Conflicts == null
                        ? new ConflictsBranch(Hash, Key, Value, new[] { new KV<K, V>(key, value) }, LeftNode, RightNode, BranchHeight)
                        : UpdateValueAndResolveConflicts(key, value, update, false, ref isUpdated, ref updatedOldValue);
                }

                if (hash < Hash)
                {
                    var left = LeftNode;
                    if (left == null)
                        return CreateBranch(Hash, Key, Value, Conflicts, new ImHashMap<K, V>(hash, key, value), RightNode, BranchHeight);

                    var leftBranch = left as Branch;

                    // Left is the Leaf node without producing garbage intermediate results
                    if (leftBranch == null)
                    {
                        if (hash == left.Hash)
                        {
                            if (ReferenceEquals(left.Key, key) || left.Key.Equals(key))
                            {
                                var newValue = update(left.Key, left.Value, value);
                                if (ReferenceEquals(newValue, left.Value) || newValue?.Equals(left.Value) == true)
                                    return this;

                                isUpdated = true;
                                updatedOldValue = left.Value;
                                return CreateBranch(Hash, Key, Value, Conflicts,
                                    CreateLeaf(hash, key, newValue, left.Conflicts), RightNode, BranchHeight);
                            }

                            return CreateBranch(Hash, Key, Value, Conflicts,
                                left.Conflicts == null
                                    ? new ConflictsLeaf(left.Hash, left.Key, left.Value, new[] { new KV<K, V>(key, value) })
                                    : left.UpdateValueAndResolveConflicts(key, value, update, false, ref isUpdated, ref updatedOldValue),
                                RightNode, BranchHeight);
                        }

                        if (hash < left.Hash)
                        {
                            // single rotation:
                            //      5     =>     2
                            //   2            1     5
                            // 1
                            if (RightNode == null)
                                return CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts,
                                    new ImHashMap<K, V>(hash, key, value),
                                    CreateLeaf(Hash, Key, Value, Conflicts), 2);

                            leftBranch = CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts,
                                new ImHashMap<K, V>(hash, key, value), null, 2);
                        }
                        else
                        {
                            // double rotation
                            //      5     =>    5     =>    4
                            //   2           4           2     5
                            //    4         2
                            if (RightNode == null)
                                return new Branch(hash, key, value,
                                    CreateLeaf(left.Hash, left.Key, left.Value, left.Conflicts),
                                    CreateLeaf(Hash, Key, Value, Conflicts), 2);

                            leftBranch = CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts,
                                null, new ImHashMap<K, V>(hash, key, value), 2);
                        }
                    }
                    else
                    {
                        var oldLeftBranch = leftBranch;
                        leftBranch = leftBranch.AddOrUpdateBranch(hash, key, value, update, ref isUpdated, ref updatedOldValue);
                        if (isUpdated)
                            return CreateBranch(Hash, Key, Value, Conflicts, leftBranch, RightNode, BranchHeight);
                        if (leftBranch == oldLeftBranch)
                            return this;
                    }

                    var rightHeight = (RightNode as Branch)?.BranchHeight ?? 1;
                    var leftHeight = leftBranch.BranchHeight;
                    if (leftHeight - rightHeight <= 1)
                        return CreateBranch(Hash, Key, Value, Conflicts, leftHeight, leftBranch, rightHeight, RightNode);

                    // Also means that left is branch and not the leaf
                    // ReSharper disable once PossibleNullReferenceException
                    var leftLeft = leftBranch.LeftNode;
                    var leftRight = leftBranch.RightNode;

                    // The left is at least have height >= 2 and assuming that it is balanced and no node is updated (handled early),
                    // it should not have `null` left or right
                    //Debug.Assert(leftLeft != null && leftRight != null);
                    var llb = leftLeft as Branch;
                    var lrb = leftRight as Branch;
                    var leftLeftHeight = llb?.BranchHeight ?? 1;
                    var leftRightHeight = lrb?.BranchHeight ?? 1;
                    if (leftRightHeight > leftLeftHeight)
                    {
                        // double rotation:
                        //      5     =>     5     =>     4
                        //   2     6      4     6      2     5
                        // 1   4        2   3        1   3     6
                        //    3        1
                        // ReSharper disable once PossibleNullReferenceException
                        return CreateBranch(leftRight.Hash, leftRight.Key, leftRight.Value, leftRight.Conflicts,
                            CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts, leftLeftHeight, leftLeft, lrb?.LeftNode),
                            CreateBranch(Hash, Key, Value, Conflicts, lrb?.RightNode, rightHeight, RightNode));
                    }

                    // one rotation:
                    //      5     =>     2
                    //   2     6      1     5
                    // 1   4              4   6
                    var newRightHeight = leftRightHeight > rightHeight ? leftRightHeight + 1 : rightHeight + 1;
                    return CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts,
                        leftLeftHeight, leftLeft,
                        newRightHeight, CreateBranch(Hash, Key, Value, Conflicts, leftRight, RightNode, newRightHeight));
                }
                else
                {
                    var right = RightNode;
                    if (right == null)
                        return CreateBranch(Hash, Key, Value, Conflicts, LeftNode, new ImHashMap<K, V>(hash, key, value), BranchHeight);

                    var rightBranch = right as Branch;
                    if (rightBranch == null)
                    {
                        if (hash == right.Hash)
                        {
                            if (ReferenceEquals(right.Key, key) || right.Key.Equals(key))
                            {
                                var newValue = update(right.Key, right.Value, value);
                                if (ReferenceEquals(newValue, right.Value) || newValue?.Equals(right.Value) == true)
                                    return this;

                                isUpdated = true;
                                updatedOldValue = right.Value;
                                return CreateBranch(Hash, Key, Value, Conflicts,
                                    LeftNode, CreateLeaf(hash, key, newValue, right.Conflicts), BranchHeight);
                            }

                            return CreateBranch(Hash, Key, Value, Conflicts, LeftNode,
                                right.Conflicts == null
                                    ? new ConflictsLeaf(right.Hash, right.Key, right.Value, new[] { new KV<K, V>(key, value) })
                                    : right.UpdateValueAndResolveConflicts(key, value, update, false, ref isUpdated, ref updatedOldValue),
                                BranchHeight);
                        }

                        if (hash > right.Hash)
                        {
                            // single rotation:
                            //      5     =>      6
                            //        6        5     7
                            //          7
                            if (LeftNode == null)
                                return CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts,
                                    CreateLeaf(Hash, Key, Value, Conflicts),
                                    new ImHashMap<K, V>(hash, key, value), 2);

                            rightBranch = CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts,
                                null, new ImHashMap<K, V>(hash, key, value), 2);
                        }
                        else
                        {
                            // double rotation
                            //      5     =>    5     =>     6
                            //         7          6        5   7
                            //        6            7
                            if (LeftNode == null)
                                return new Branch(hash, key, value,
                                    CreateLeaf(Hash, Key, Value, Conflicts),
                                    CreateLeaf(right.Hash, right.Key, right.Value, right.Conflicts), 2);

                            rightBranch = CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts,
                                new ImHashMap<K, V>(hash, key, value), null, 2);
                        }
                    }
                    else
                    {
                        var oldRightBranch = rightBranch;
                        rightBranch = rightBranch.AddOrUpdateBranch(hash, key, value, update, ref isUpdated, ref updatedOldValue);
                        if (isUpdated)
                            return CreateBranch(Hash, Key, Value, Conflicts, LeftNode, rightBranch, BranchHeight);
                        if (rightBranch == oldRightBranch)
                            return this;
                    }

                    var leftHeight = (LeftNode as Branch)?.BranchHeight ?? 1;
                    var rightHeight = rightBranch.BranchHeight;
                    if (rightHeight - leftHeight <= 1)
                        return CreateBranch(Hash, Key, Value, Conflicts, leftHeight, LeftNode, rightHeight, rightBranch);

                    // ReSharper disable once PossibleNullReferenceException
                    var rightLeft = rightBranch.LeftNode;
                    var rightRight = rightBranch.RightNode;

                    var rlb = rightLeft as Branch;
                    var rrb = rightRight as Branch;
                    var rightLeftHeight = rlb?.BranchHeight ?? 1;
                    var rightRightHeight = rrb?.BranchHeight ?? 1;
                    if (rightLeftHeight > rightRightHeight)
                    {
                        // ReSharper disable once PossibleNullReferenceException
                        return CreateBranch(rightLeft.Hash, rightLeft.Key, rightLeft.Value, rightLeft.Conflicts,
                            CreateBranch(Hash, Key, Value, Conflicts, leftHeight, LeftNode, rlb?.LeftNode),
                            CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts, rlb?.RightNode, rightRightHeight, rightRight));
                    }

                    var newLeftHeight = leftHeight > rightLeftHeight ? leftHeight + 1 : rightLeftHeight + 1;
                    return CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts,
                        newLeftHeight, CreateBranch(Hash, Key, Value, Conflicts, LeftNode, rightLeft, newLeftHeight),
                        rightRightHeight, rightRight);
                }
            }

            private new Branch UpdateValueAndResolveConflicts(
                K key, V value, Update<K, V> update, bool updateOnly, ref bool updated, ref V oldValue)
            {
                if (Conflicts == null) // add only if updateOnly is false.
                    return updateOnly
                        ? this
                        : new ConflictsBranch(Hash, Key, Value, new[] { new KV<K, V>(key, value) },
                            LeftNode, RightNode, BranchHeight);

                var found = Conflicts.Length - 1;
                while (found >= 0 && !Equals(Conflicts[found].Key, Key)) --found;
                if (found == -1)
                {
                    if (updateOnly)
                        return this;

                    var newConflicts = new KV<K, V>[Conflicts.Length + 1];
                    Array.Copy(Conflicts, 0, newConflicts, 0, Conflicts.Length);
                    newConflicts[Conflicts.Length] = new KV<K, V>(key, value);

                    return new ConflictsBranch(Hash, Key, Value, newConflicts, LeftNode, RightNode, BranchHeight);
                }

                var conflicts = new KV<K, V>[Conflicts.Length];
                Array.Copy(Conflicts, 0, conflicts, 0, Conflicts.Length);

                if (update == null)
                    conflicts[found] = new KV<K, V>(key, value);
                else
                {
                    var conflict = conflicts[found];
                    var newValue = update(conflict.Key, conflict.Value, value);
                    if (ReferenceEquals(newValue, conflict.Value) || newValue?.Equals(conflict.Value) == true)
                        return this;

                    updated = true;
                    oldValue = conflict.Value;
                    conflicts[found] = new KV<K, V>(key, newValue);
                }

                return new ConflictsBranch(Hash, Key, Value, conflicts, LeftNode, RightNode, BranchHeight);
            }
        }

        /// Branch with the conflicts
        public sealed class ConflictsLeaf : ImHashMap<K, V>
        {
            /// In case of Hash conflicts for different keys contains conflicted keys with their values.
            public override KV<K, V>[] Conflicts { get; }

            /// Creates the branch node
            internal ConflictsLeaf(
                int hash, K key, V value, KV<K, V>[] conflicts) : base(hash, key, value)
            {
                Conflicts = conflicts;
            }
        }

        /// Branch with the conflicts
        public sealed class ConflictsBranch : Branch
        {
            /// In case of Hash conflicts for different keys contains conflicted keys with their values.
            public override KV<K, V>[] Conflicts { get; }

            /// Creates the branch node with known height
            internal ConflictsBranch(
                int hash, K key, V value, KV<K, V>[] conflicts,
                ImHashMap<K, V> left, ImHashMap<K, V> right, int height) :
                base(hash, key, value, left, right, height)
            {
                Conflicts = conflicts;
            }
        }

        /// <summary>Returns new tree with added key-value. 
        /// If value with the same key is exist then the value is replaced.</summary>
        /// <param name="key">Key to add.</param><param name="value">Value to add.</param>
        /// <returns>New tree with added or updated key-value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value) =>
            this == Empty
                ? new ImHashMap<K, V>(key.GetHashCode(), key, value)
                : AddOrUpdate(key.GetHashCode(), key, value);

        /// <summary>Returns new tree with added key-value. If value with the same key is exist, then
        /// if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
        /// if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
        /// <param name="key">Key to add.</param><param name="value">Value to add.</param>
        /// <param name="update">Update handler.</param>
        /// <returns>New tree with added or updated key-value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<V> update) =>
            this == Empty
                ? new ImHashMap<K, V>(key.GetHashCode(), key, value)
                : AddOrUpdate(key.GetHashCode(), key, value, update);

        /// Returns the previous value if updated.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, out bool isUpdated, out V updatedOldValue, Update<K, V> update)
        {
            isUpdated = false;
            updatedOldValue = default(V);
            var hash = key.GetHashCode();
            if (this == Empty)
                return new ImHashMap<K, V>(hash, key, value);

            var branch = this as Branch;
            return branch == null
                ? AddOrUpdateLeaf(hash, key, value, update, ref isUpdated, ref updatedOldValue)
                : branch.AddOrUpdateBranch(hash, key, value, update, ref isUpdated, ref updatedOldValue);
        }

        private ImHashMap<K, V> AddOrUpdateLeaf(int hash, K key, V value, Update<K, V> update, ref bool isUpdated, ref V updatedOldValue)
        {
            if (hash == Hash)
            {
                if (ReferenceEquals(Key, key) || Key.Equals(key))
                {
                    var newValue = update(Key, Value, value);
                    if (ReferenceEquals(newValue, Value) || newValue?.Equals(Value) == true)
                        return this;

                    isUpdated = true;
                    updatedOldValue = Value;
                    return CreateLeaf(hash, key, newValue, Conflicts);
                }

                return Conflicts == null
                    ? new ConflictsLeaf(Hash, Key, Value, new[] { new KV<K, V>(key, value) })
                    : UpdateValueAndResolveConflicts(key, value, update, false, ref isUpdated, ref updatedOldValue);
            }

            return hash < Hash
                ? CreateBranch(Hash, Key, Value, Conflicts, new ImHashMap<K, V>(hash, key, value), null, 2)
                : CreateBranch(Hash, Key, Value, Conflicts, null, new ImHashMap<K, V>(hash, key, value), 2);
        }

        /// <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
        /// runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
        /// <param name="key">Key to look for.</param>
        /// <param name="value">New value to replace key value with.</param>
        /// <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
        /// as inputs and should return updated value as output.</param>
        /// <returns>New tree with updated value or the SAME tree if no key found.</returns>
        public ImHashMap<K, V> Update(K key, V value, Update<V> update = null) =>
            Update(key.GetHashCode(), key, value, update);

        /// <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
        /// <returns>Sequence of enumerated key value pairs.</returns>
        public IEnumerable<KV<K, V>> Enumerate()
        {
            if (this == Empty)
                yield break;

            var node = this;
            var height = node is Branch b ? b.BranchHeight : 1;
            var parents = new ImHashMap<K, V>[height];
            var parentCount = -1;
            while (height != 0 || parentCount != -1)
            {
                if (height != 0)
                {
                    parents[++parentCount] = node;
                    node = (node as Branch)?.LeftNode; // null is fine cause GetHeight handles the null
                }
                else
                {
                    node = parents[parentCount--];
                    yield return new KV<K, V>(node.Key, node.Value);

                    var conflicts = node.Conflicts;
                    if (conflicts != null)
                        for (var i = 0; i < conflicts.Length; i++)
                            yield return conflicts[i];

                    node = (node as Branch)?.RightNode;
                }

                height = node == null ? 0 : node is Branch br ? br.BranchHeight : 1;
            }
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Remove(K key) =>
            Remove(key.GetHashCode(), key);

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : (Key + ":" + Value);

        #region Implementation

        private ImHashMap() { }

        /// Creates the leaf node
        protected ImHashMap(int hash, K key, V value)
        {
            Hash = hash;
            Key = key;
            Value = value;
        }

        /// It is fine
        private ImHashMap<K, V> AddOrUpdate(int hash, K key, V value, Update<V> update = null)
        {
            var branch = this as Branch;
            if (hash == Hash)
            {
                if (ReferenceEquals(Key, key) || Key.Equals(key))
                {
                    value = update == null ? value : update(Value, value);
                    return branch == null
                        ? CreateLeaf(hash, key, value, Conflicts)
                        : CreateBranch(hash, key, value, Conflicts, branch.LeftNode, branch.RightNode, branch.BranchHeight);
                }
                return UpdateValueAndResolveConflicts(key, value, update, false);
            }

            return hash < Hash
                ? With(branch?.LeftNode?.AddOrUpdate(hash, key, value, update) ?? new ImHashMap<K, V>(hash, key, value), branch?.RightNode)
                : With(branch?.LeftNode, branch?.RightNode?.AddOrUpdate(hash, key, value, update) ?? new ImHashMap<K, V>(hash, key, value));
        }

        /// It is fine.
        public ImHashMap<K, V> Update(int hash, K key, V value, Update<V> update = null)
        {
            var branch = this as Branch;
            var height = branch?.BranchHeight ?? 1;
            if (height == 0)
                return this;

            return hash == Hash
                ? (ReferenceEquals(Key, key) || Key.Equals(key)
                    ? CreateNode(hash, key, update == null ? value : update(Value, value), Conflicts,
                        branch?.LeftNode, branch?.RightNode, height)
                    : UpdateValueAndResolveConflicts(key, value, update, true))
                : (hash < Hash
                    ? With(branch?.LeftNode?.Update(hash, key, value, update), branch?.RightNode)
                    : With(branch?.LeftNode, branch?.RightNode?.Update(hash, key, value, update)));
        }

        private ImHashMap<K, V> UpdateValueAndResolveConflicts(K key, V value, Update<V> update, bool updateOnly)
        {
            var br = this as Branch;
            var height = br?.BranchHeight ?? 1;
            if (Conflicts == null) // add only if updateOnly is false.
            {
                if (updateOnly)
                    return this;
                return CreateConflictsNode(Hash, Key, Value, new[] { new KV<K, V>(key, value) },
                    br?.LeftNode, br?.RightNode, height);
            }

            var found = Conflicts.Length - 1;
            while (found >= 0 && !Equals(Conflicts[found].Key, Key)) --found;
            if (found == -1)
            {
                if (updateOnly)
                    return this;
                var newConflicts = new KV<K, V>[Conflicts.Length + 1];
                Array.Copy(Conflicts, 0, newConflicts, 0, Conflicts.Length);
                newConflicts[Conflicts.Length] = new KV<K, V>(key, value);

                return CreateConflictsNode(Hash, Key, Value, newConflicts, br?.LeftNode, br?.RightNode, height);
            }

            var conflicts = new KV<K, V>[Conflicts.Length];
            Array.Copy(Conflicts, 0, conflicts, 0, Conflicts.Length);
            conflicts[found] = new KV<K, V>(key, update == null ? value : update(Conflicts[found].Value, value));

            return CreateConflictsNode(Hash, Key, Value, conflicts, br?.LeftNode, br?.RightNode, height);
        }

        private ImHashMap<K, V> UpdateValueAndResolveConflicts(
            K key, V value, Update<K, V> update, bool updateOnly, ref bool updated, ref V oldValue)
        {
            var branch = this as Branch;
            var height = branch?.BranchHeight ?? 1;
            if (Conflicts == null) // add only if updateOnly is false.
            {
                if (updateOnly)
                    return this;
                return CreateConflictsNode(Hash, Key, Value, new[] { new KV<K, V>(key, value) },
                    branch?.LeftNode, branch?.RightNode, height);
            }

            var found = Conflicts.Length - 1;
            while (found >= 0 && !Equals(Conflicts[found].Key, Key)) --found;
            if (found == -1)
            {
                if (updateOnly)
                    return this;

                var newConflicts = new KV<K, V>[Conflicts.Length + 1];
                Array.Copy(Conflicts, 0, newConflicts, 0, Conflicts.Length);
                newConflicts[Conflicts.Length] = new KV<K, V>(key, value);

                return CreateConflictsNode(Hash, Key, Value, newConflicts, branch?.LeftNode, branch?.RightNode, height);
            }

            var conflicts = new KV<K, V>[Conflicts.Length];
            Array.Copy(Conflicts, 0, conflicts, 0, Conflicts.Length);

            if (update == null)
                conflicts[found] = new KV<K, V>(key, value);
            else
            {
                var conflict = conflicts[found];
                var newValue = update(conflict.Key, conflict.Value, value);
                if (ReferenceEquals(newValue, conflict.Value) || newValue?.Equals(conflict.Value) == true)
                    return this;

                updated = true;
                oldValue = conflict.Value;
                conflicts[found] = new KV<K, V>(key, newValue);
            }

            return CreateConflictsNode(Hash, Key, Value, conflicts, branch?.LeftNode, branch?.RightNode, height);
        }

        /// It is fine.
        public V GetConflictedValueOrDefault(K key, V defaultValue)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = conflicts.Length - 1; i >= 0; --i)
                    if (Equals(conflicts[i].Key, key))
                        return conflicts[i].Value;
            }
            return defaultValue;
        }

        /// It is fine.
        internal bool TryFindConflictedValue(K key, out V value)
        {
            if (Conflicts != null)
            {
                var conflicts = Conflicts;
                for (var i = conflicts.Length - 1; i >= 0; --i)
                    if (Equals(conflicts[i].Key, key))
                    {
                        value = conflicts[i].Value;
                        return true;
                    }
            }

            value = default(V);
            return false;
        }

        private ImHashMap<K, V> With(ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            var branch = this as Branch;
            if (left == branch?.LeftNode && right == branch?.RightNode)
                return this;
            return Balance(Hash, Key, Value, Conflicts, left, right);
        }

        private static ImHashMap<K, V> CreateNode(int hash, K key, V value, KV<K, V>[] conflicts,
            ImHashMap<K, V> left, ImHashMap<K, V> right, int height)
        {
            if (height == 1)
                return conflicts == null
                    ? new ImHashMap<K, V>(hash, key, value)
                    : new ConflictsLeaf(hash, key, value, conflicts);
            return conflicts == null
                ? new Branch(hash, key, value, left, right, height)
                : new ConflictsBranch(hash, key, value, conflicts, left, right, height);
        }

        [MethodImpl((MethodImplOptions)256)]
        private static ImHashMap<K, V> CreateNode(int hash, K key, V value,
            ImHashMap<K, V> left, ImHashMap<K, V> right, int height) =>
            height == 1
                ? new ImHashMap<K, V>(hash, key, value)
                : new Branch(hash, key, value, left, right, height);

        [MethodImpl((MethodImplOptions)256)]
        private static ImHashMap<K, V> CreateConflictsNode(int hash, K key, V value, KV<K, V>[] conflicts,
            ImHashMap<K, V> left, ImHashMap<K, V> right, int height) =>
            height == 1
                ? (ImHashMap<K, V>)new ConflictsLeaf(hash, key, value, conflicts)
                : new ConflictsBranch(hash, key, value, conflicts, left, right, height);

        [MethodImpl((MethodImplOptions)256)]
        private static Branch CreateBranch(int hash, K key, V value, KV<K, V>[] conflicts,
            ImHashMap<K, V> left, ImHashMap<K, V> right, int height) =>
            conflicts == null
                ? new Branch(hash, key, value, left, right, height)
                : new ConflictsBranch(hash, key, value, conflicts, left, right, height);

        [MethodImpl((MethodImplOptions)256)]
        private static Branch CreateBranch(int hash, K key, V value, KV<K, V>[] conflicts,
            int leftHeight, ImHashMap<K, V> left, ImHashMap<K, V> right) =>
            CreateBranch(hash, key, value, conflicts,
                leftHeight, left, right == null ? 0 : (right as Branch)?.BranchHeight ?? 1, right);

        [MethodImpl((MethodImplOptions)256)]
        private static Branch CreateBranch(int hash, K key, V value, KV<K, V>[] conflicts,
            ImHashMap<K, V> left, int rightHeight, ImHashMap<K, V> right) =>
            CreateBranch(hash, key, value, conflicts,
                left == null ? 0 : (left as Branch)?.BranchHeight ?? 1, left, rightHeight, right);

        [MethodImpl((MethodImplOptions)256)]
        private static Branch CreateBranch(int hash, K key, V value, KV<K, V>[] conflicts,
            int leftHeight, ImHashMap<K, V> left, int rightHeight, ImHashMap<K, V> right)
        {
            var height = leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;
            return conflicts == null
                ? new Branch(hash, key, value, left, right, height)
                : new ConflictsBranch(hash, key, value, conflicts, left, right, height);
        }

        [MethodImpl((MethodImplOptions)256)]
        private static Branch CreateBranch(int hash, K key, V value, KV<K, V>[] conflicts,
            ImHashMap<K, V> left, ImHashMap<K, V> right) =>
            CreateBranch(hash, key, value, conflicts,
                left == null ? 0 : (left as Branch)?.BranchHeight ?? 1, left,
                right == null ? 0 : (right as Branch)?.BranchHeight ?? 1, right);

        [MethodImpl((MethodImplOptions)256)]
        private static ImHashMap<K, V> CreateLeaf(int hash, K key, V value, KV<K, V>[] conflicts) =>
            conflicts == null
                ? new ImHashMap<K, V>(hash, key, value)
                : new ConflictsLeaf(hash, key, value, conflicts);

        private static ImHashMap<K, V> Balance(
            int hash, K key, V value, KV<K, V>[] conflicts, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            var leftBranch = left as Branch;
            var leftHeight = left == null ? 0 : leftBranch?.BranchHeight ?? 1;

            var rightBranch = right as Branch;
            var rightHeight = right == null ? 0 : rightBranch?.BranchHeight ?? 1;

            var delta = leftHeight - rightHeight;
            if (delta > 1) // left is longer by 2, rotate left
            {
                // Also means that left is branch and not the leaf
                // ReSharper disable once PossibleNullReferenceException
                var leftLeft = leftBranch.LeftNode;
                var leftRight = leftBranch.RightNode;

                var llb = leftLeft as Branch;
                var lrb = leftRight as Branch;

                // The left is at least have height >= 2 and assuming that it is balanced, it should not have `null` left or right
                var leftLeftHeight = leftLeft == null ? 0 : llb?.BranchHeight ?? 1;
                var leftRightHeight = leftRight == null ? 0 : lrb?.BranchHeight ?? 1;
                if (leftRightHeight > leftLeftHeight)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return CreateBranch(leftRight.Hash, leftRight.Key, leftRight.Value, leftRight.Conflicts,
                        leftLeft == null && lrb?.LeftNode == null
                            ? CreateLeaf(left.Hash, left.Key, left.Value, left.Conflicts)
                            : CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts, leftLeftHeight, leftLeft, lrb?.LeftNode),
                        lrb?.RightNode == null && right == null
                            ? CreateLeaf(hash, key, value, conflicts)
                            : CreateBranch(hash, key, value, conflicts, lrb?.RightNode, rightHeight, right));
                }

                // one rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                var newRightHeight = leftRightHeight > rightHeight ? leftRightHeight + 1 : rightHeight + 1;
                return CreateBranch(left.Hash, left.Key, left.Value, left.Conflicts,
                    leftLeft, CreateNode(hash, key, value, conflicts, leftRight, right, newRightHeight),
                    leftLeftHeight > newRightHeight ? leftLeftHeight + 1 : newRightHeight + 1);
            }

            if (delta < -1)
            {
                // ReSharper disable once PossibleNullReferenceException
                var rightLeft = rightBranch.LeftNode;
                var rightRight = rightBranch.RightNode;
                var rlb = rightLeft as Branch;
                var rrb = rightRight as Branch;

                var rightLeftHeight = rightLeft == null ? 0 : rlb?.BranchHeight ?? 1;
                var rightRightHeight = rightRight == null ? 0 : rrb?.BranchHeight ?? 1;
                if (rightLeftHeight > rightRightHeight)
                {
                    // ReSharper disable once PossibleNullReferenceException
                    return CreateBranch(rightLeft.Hash, rightLeft.Key, rightLeft.Value, rightLeft.Conflicts,
                        left == null && rlb?.LeftNode == null
                            ? CreateLeaf(hash, key, value, conflicts)
                            : CreateBranch(hash, key, value, conflicts, leftHeight, left, rlb?.LeftNode),
                        rlb?.RightNode == null && rightRight == null
                            ? CreateLeaf(right.Hash, right.Key, right.Value, right.Conflicts)
                            : CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts, rlb?.RightNode, rightRightHeight, rightRight));
                }

                var newLeftHeight = leftHeight > rightLeftHeight ? leftHeight + 1 : rightLeftHeight + 1;
                return CreateBranch(right.Hash, right.Key, right.Value, right.Conflicts,
                    CreateNode(hash, key, value, conflicts, left, rightLeft, newLeftHeight), rightRight,
                    newLeftHeight > rightRightHeight ? newLeftHeight + 1 : rightRightHeight + 1);
            }

            return CreateBranch(hash, key, value, conflicts, left, right, leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1);
        }

        internal ImHashMap<K, V> Remove(int hash, K key, bool ignoreKey = false)
        {
            var branch = this as Branch;
            var height = branch?.BranchHeight ?? 1;
            if (height == 0)
                return this;

            ImHashMap<K, V> result;
            if (hash == Hash) // found node
            {
                if (ignoreKey || Equals(Key, key))
                {
                    if (!ignoreKey && Conflicts != null)
                        return ReplaceRemovedWithConflicted();

                    if (height == 1) // remove node
                        return Empty;

                    if (branch?.RightNode == null)
                        result = branch?.LeftNode;
                    else if (branch.LeftNode == null)
                        result = branch.RightNode;
                    else
                    {
                        // we have two children, so remove the next highest node and replace this node with it.
                        var successor = branch?.RightNode;
                        while ((successor as Branch)?.LeftNode != null)
                            successor = (successor as Branch)?.LeftNode;

                        var successorBranch = successor as Branch;
                        var rightNode = successorBranch?.RightNode.Remove(successor.Hash, default(K), ignoreKey: true);
                        result = rightNode == null && successorBranch?.LeftNode == null
                            ? CreateLeaf(successor.Hash, successor.Key, successor.Value, successor.Conflicts)
                            : CreateBranch(successor.Hash, successor.Key, successor.Value, successor.Conflicts, successorBranch.LeftNode, rightNode);
                    }
                }
                else if (Conflicts != null)
                    return TryRemoveConflicted(key);
                else
                    return this; // if key is not matching and no conflicts to lookup - just return
            }
            else if (hash < Hash)
            {
                result = Balance(Hash, Key, Value, Conflicts, branch?.LeftNode.Remove(hash, key, ignoreKey), branch?.RightNode);
            }
            else
            {
                result = Balance(Hash, Key, Value, Conflicts, branch?.LeftNode, branch?.RightNode.Remove(hash, key, ignoreKey));
            }

            return result;
        }

        private ImHashMap<K, V> TryRemoveConflicted(K key)
        {
            var index = Conflicts.Length - 1;
            while (index >= 0 && !Equals(Conflicts[index].Key, key)) --index;
            if (index == -1) // key is not found in conflicts - just return
                return this;

            var branch = this as Branch;
            var height = branch?.BranchHeight ?? 1;
            if (Conflicts.Length == 1)
                return CreateNode(Hash, Key, Value, branch?.LeftNode, branch?.RightNode, height);

            var lessConflicts = new KV<K, V>[Conflicts.Length - 1];
            var newIndex = 0;
            for (var i = 0; i < Conflicts.Length; ++i)
                if (i != index) lessConflicts[newIndex++] = Conflicts[i];
            return CreateConflictsNode(Hash, Key, Value, lessConflicts, branch?.LeftNode, branch?.RightNode, height);
        }

        private ImHashMap<K, V> ReplaceRemovedWithConflicted()
        {
            var branch = this as Branch;
            var height = branch?.BranchHeight ?? 1;

            if (Conflicts.Length == 1)
                return CreateNode(Hash, Conflicts[0].Key, Conflicts[0].Value, branch?.LeftNode, branch?.RightNode, height);

            var lessConflicts = new KV<K, V>[Conflicts.Length - 1];
            Array.Copy(Conflicts, 1, lessConflicts, 0, lessConflicts.Length);
            return CreateConflictsNode(Hash, Conflicts[0].Key, Conflicts[0].Value, lessConflicts, branch?.LeftNode, branch?.RightNode, height);
        }

        #endregion
    }

    /// Map methods
    public static class ImHashMap
    {
        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue = default(V))
        {
            var hash = key.GetHashCode();
            while (map != null)
            {
                if (map.Hash == hash)
                    return ReferenceEquals(key, map.Key) || key.Equals(map.Key)
                        ? map.Value
                        : map.GetConflictedValueOrDefault(key, defaultValue);

                map = hash < map.Hash
                    ? (map as ImHashMap<K, V>.Branch)?.LeftNode
                    : (map as ImHashMap<K, V>.Branch)?.RightNode;
            }

            return defaultValue;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value)
        {
            var hash = key.GetHashCode();
            while (map != null)
            {
                if (map.Hash == hash)
                {
                    if (ReferenceEquals(key, map.Key) || key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }
                    return map.TryFindConflictedValue(key, out value);
                }

                map = hash < map.Hash
                    ? (map as ImHashMap<K, V>.Branch)?.LeftNode
                    : (map as ImHashMap<K, V>.Branch)?.RightNode;
            }

            value = default(V);
            return false;
        }
    }
}
